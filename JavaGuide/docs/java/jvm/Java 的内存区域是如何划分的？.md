# Java 的内存区域是如何划分的？

首先:jvm 是将二进制文件加载之后运行得, 

包括类加载器,然后进入内存区域去运行, 这个内存是怎么划分的呢?

## 1. 方法区

 这个方法区域, 一个类经过类加载器之后,会在方法区中,存放当前类的模板 class 文件

![img](https://static001.geekbang.org/infoq/59/59af212d6e35c1b9e388112ce91ee520.png)



 **方法区域:**

**注意事项:**  

  **方法区又名(method area)静态区 ,存放所有的类 Class 的对象, 被所有线城所共享**

  **存放 static 修饰的变量,方法区中包含的都是在整个程序中永远唯一的元素，如 class，static 变量。**

 方法区域也会存在很多对于静态变量啊,静态方法等一些数据, 



## 2.堆空间:(heap):

   

  **堆空间中存储对象**,所有 new 出来的对象都存在堆空间, 

 堆管存储,栈管运行,

![img](https://static001.geekbang.org/infoq/27/27c226b57cc5a331cb8a288eda1ce941.png)



## 3.程序计数器:

![img](https://static001.geekbang.org/infoq/b3/b3840deebc759d34e86d3481062b3991.png)



**基于 JVM 中 多个线程执行方法-->方法代码**

![img](https://static001.geekbang.org/infoq/a4/a40e3ee73e2ae40cc79c97f052e51428.png)



 因为所有的线程运行方法, 都会创建一个当前线程的**虚拟机栈**,用来**存储方法中的局部变量;**

 **所有,只要是程序运行,就会有虚拟机栈存在,**

![img](https://static001.geekbang.org/infoq/bf/bfa7c1803ee9c03590b64cffa1f3d8fb.png)



**如果有多个递归的方法嵌套, 此时, 这个因为当前虚拟机栈里面的栈帧**

![img](https://static001.geekbang.org/infoq/c6/c6509b76803a9393a57c714a1fd783e0.png)



![img](https://static001.geekbang.org/infoq/d3/d341681620215ceaae132815afb2d396.png)



![img](https://static001.geekbang.org/infoq/9e/9e59442b85f1cd2997501adc303b0f9b.png)



## 4. 一个类在内存从加载到运行,然后到消亡的过程?

  

   **首先, 当二进制的字节码文件 class,经过类加载器,加载到 jvm 中之后, jvm 各个部分就开始分工合作了;**



**(1) 对象 class 加载到**静态区**---方法区,存放 static 修饰的成员变量**



**(2) 开始运行,线程开始创建一个虚拟机栈空间, 用于方法的运行(程序的运行都是靠方法的调用) ,每个方法中的成员变量会创建一个****栈帧**



 **写入虚拟机栈中, 栈空间存储数据的交换以及处理,** 

 **然后如果需要创建当前类的实例化对象,  经过从方法区,Java 的反射机制创建出实例化对象,**



**(3)实例化的对象存储在堆空间中,唯一只存在堆空间的就是 class 对象, 是普通的实例化对象**

 

**(4) 对象调用方法, 栈空间读取当前对象的引用地址,开始进行复杂的计算, 然后方法结束**

 **获取结果,结束,垃圾回收,方法完结**



**注意事项****:**

 **当前内存区域中, 只存在堆管存储对象,栈管运行方法和存储对象的引用地址,** 



**类加载运行在 JVM 的细节过程**

![img](https://static001.geekbang.org/infoq/76/76e270a597543bf22d22f65a59eb3af9.png)